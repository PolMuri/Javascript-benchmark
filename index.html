<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS Benchmark</title>
    <style>
        *, *::before, *::after{
            /* Perquè el padding compti com a amplada*/
            box-sizing: border-box;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 
            Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background: #1e1e1e;
            color: #fff;
            margin: 0;
            padding: 16px;
        }

        .container{
            display: flex;
            flex-direction: column;
            gap: 16px;
            max-width: 1280px;
            margin: auto;

            h2 {
                font-size: 12px;
                opacity: .5;
                font-weight: 500;
                margin: 0;
                padding: o;
            }
        }

        .code {
            background: #141414;
            border-radius: 6px;
            border: 0;
            color: #d4d4d4;
            font-family: monospace;
            font-size: 12px;
            padding: 8px;
            /* El resize none és perquè l'usuari no pugui canviar i moure el tamany
            de la finestra del textarea que porta com a nom de classe code*/
            resize: none;
            width: 100%;
            /* És una propietat nova en CSS que al apretar enter al textarea es fa gran
            de forma automàtica ja que s'adapta al contingut i així no ens cal el resize
            i s'adapta al contingut de forma automàtica*/
            field-sizing: content;

        }

        .test-cases {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .test-case {
            background: #2a2a2a;
            border-radius: 6px;
            display: flex;
            flex-direction: column;

            header {
                display: flex;
                /* Perquè posi les operacions a la cantonada superior dreta completament separada
                del número de l'span que hem posat manualment */
                justify-content: space-between;
                font-size: 12px;
                padding: 8px;
                align-items: center;

                .test-id {
                    border-radius: 100%;
                    background: #141414;
                    width: 20px;
                    height: 20px;
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    text-align: center;
                    color: rgba(255, 255, 255, .7);
                }

                .ops {
                    opacity: .5;
                    font-size: 9px;
                }
            }

            .code {
                /* Així el border-radius només apareix a les cantonades de sota dels textarea
                que nosaltres tenim com a classe code */
                border-radius: 0 0 6px 6px;
            }
        }

        .send-button {
            border-radius: 6px;
            background: rgba(255, 255, 255, .3);
            border: 0;
            color: white;
            cursor: pointer;
            padding: 6px 12px;
            transition: background .3s ease;
            width: fit-content;
            /* Quan fem hover passarà el següent*/
            &:hover {
                background: rgba(255, 255, 255, .5);
            }

        }
    </style>

    <script type="module">
        /* Recuperarem tots els elements que ens interessen */
        // Utilitzem les variables per indentificar els elements del DOM i fer-ho més fàcil
        const $globalCode = document.querySelector('#global') // Per recuperar el text de global que el necessitarem per iniciar el benchmark
        const $sendbutton = document.querySelector('.send-button')

        // Funció per executar el test i li passem el codi i la data que serveix per inicialitzar cada un dels casos
        // i necessitem el codi tant de global com dels test cases per inicialitzar cada un dels casos
        // Amb aquesta funció estem calculant el número d'operacions que fa al segon cada un dels casos
        async function runTest({code, data}) {
            // Especifiquem la duració
            const duration = 1000 // és en milisegons = 1 segon

            let result
            try {
            /* Ara calculem quantes operacions fa i hem de saber en quin punt ha d'acabar de comptar les operacions que fa
            Executem el codi dins una eval, tot el codi serà en el client, no l'injectem a cap BD ni res, per tant l'eval aquí no és perillosa
            Perquè qui provi codi no tingui accés la context de fora i per si es asincron el codi
            ho embolcallarem tot en una funció asincrona i ho autoexecutem
            L'eval ens permet evaluar una cadena de text i l'executa com si fos codi JS, però és perillós perquè es podria permetre que un usuari guardi codi a una BD 
            i que estigui injectant codi. En aquest cas és en el client per tant no és perillós*/
            result = await eval(`(async () => { 
                // Perquè no colisioni amb el que injectem a data, posem aquests noms de variables
                let PERF__ops = 0;
                let PERF__start = Date.now(); // El Date.now ens el dona en milisegons 
                let PERF__end = Date.now() + ${duration};
                // Aquí injectem la data que ha d'estar fóra del bucle
                ${data};

              while (Date.now() < PERF__end) {
                // Comptarem cada una de les operacions del codi que executi en un segon
                ${code};
                PERF__ops++
                }
                return PERF__ops
            })()`) // Això s'anomena IIFE -> Inmediately Invoked Function Expression que és crear una funció i executar-la al invocar-la
            } catch (error) {

            }

            // Per saber quantes operacions hem fet per segon return result * (1000 / duration), però com que 1000 és 1 segon retornem el resultat
            return result;
            
            
        }
    
        // Funció per executar tots els casos
        async function runTestCases(params) {
            const $testCases = document.querySelectorAll('.test-case') // Recuperem tots els elements test-case
            // Aquí és un ocorre tot, primer recuperarem el codi global que injectem a cada un dels casos
            const globalCode = $globalCode.value

            // Per cada un dels casos que tenim, s'ha d'executar
            $testCases.forEach(async testCase => {
                // Primer de tot recuperem el codi que és l'element classe "code" al textarea
                // No fa falta utilitzar sempre document.querySelector ja que una vegada recuperem un element del document podem fer 
                // un querySelector d'aquell element del document així no busquem en tot el document
                // Així dins de la classe test-cases podem buscar les altres classes
                const $code = testCase.querySelector('.code')
                const $ops = testCase.querySelector('.ops')

                // Recuperem el codi de la textarea just abans de començar el test
                const codeValue = $code.value
                // Abans d'executar els test posarem això on van les operacions per segon, ja que no té sentit posar operacions per segon
                // si encar ano s'han fet els test
                $ops.textContent = 'Loading...'

                const result = await runTest({code: codeValue, data: globalCode}) // Await espera el resultat de la funció asíncrona
                console.log(result)
            })
            
        }
        // Per executar els test-cases al iniciar
        runTestCases()

        // Cada vegada que s'apreti el botó farem un "run" del test-cases
        $sendbutton.addEventListener('click', () => {
            runTestCases()
        })
    </script>
</head>
<body>
    <main class="container">
        <h2>Global</h2>
        <textarea id="global" class="code" rows="1">const data = [...Array
            (1000).keys()]</textarea>

        <h2>Test cases</h2>
        <div class="test-cases">
            <article class="test-case">
                <header>
                    <span class="test-id">1</span>
                    <spanz class="ops">203, 360 ops/s</spanz>
                </header>

                <textarea id="global" class="code" rows="1">data.find(x => x == 100)</textarea>
            </article>

            <article class="test-case">
                <header>
                    <span class="test-id">2</span>
                    <spanz class="ops">150, 360 ops/s</spanz>
                </header>
                
                <textarea id="global" class="code" rows="1">data.find(x => x == 200)</textarea>
            </article>

            <article class="test-case">
                <header>
                    <span class="test-id">3</span>
                    <spanz class="ops">100, 360 ops/s</spanz>
                </header>
                
                <textarea id="global" class="code" rows="1">data.find(x => x == 400)</textarea>
            </article>

            <article class="test-case">
                <header>
                    <span class="test-id">4</span>
                    <spanz class="ops">50, 360 ops/s</spanz>
                </header>
                
                <textarea id="global" class="code" rows="1">data.find(x => x == 800)</textarea>
            </article>
        </div>

        <button class="send-button">Test code! </button>
    </main>
</body>
</html>